// Code generated by protoc-gen-httpinterface. DO NOT EDIT.
package {{ .PackageName }}

import (
	"fmt"
	"net/http"
	"strings"
)

// Middleware represents a middleware function that wraps an http.Handler
type Middleware func(http.Handler) http.Handler

// Routes defines methods for registering routes
type Routes interface {
	// HandleFunc registers a handler function for the given method and pattern
	HandleFunc(method, pattern string, handler http.HandlerFunc, middlewares ...Middleware)
	
	// Group creates a new RouteGroup with the given prefix and optional middlewares
	Group(prefix string, middlewares ...Middleware) *RouteGroup
	
	// Use applies middlewares to all routes registered after this call
	Use(middlewares ...Middleware) *RouteGroup
}

// RouteGroup represents a group of routes with a common prefix and middleware
type RouteGroup struct {
	mux             *http.ServeMux
	prefix          string
	middlewares     []Middleware
	// Track registered paths to prevent duplicates
	registeredPaths map[string]bool
}

// NewRouter creates a new router (which is just a RouteGroup with root prefix)
func NewRouter() *RouteGroup {
	return &RouteGroup{
		mux:             http.NewServeMux(),
		prefix:          "",
		middlewares:     []Middleware{},
		registeredPaths: make(map[string]bool),
	}
}

// Group creates a new RouteGroup with the given prefix and optional middlewares
func (g *RouteGroup) Group(prefix string, middlewares ...Middleware) *RouteGroup {
	// Ensure prefix starts with /
	if prefix != "" && !strings.HasPrefix(prefix, "/") {
		prefix = "/" + prefix
	}
	
	// If prefix is just "/", don't add it again
	if g.prefix == "/" && prefix == "/" {
		prefix = "/"
	} else if prefix == "/" {
		prefix = g.prefix
	} else {
		prefix = g.prefix + prefix
	}
	
	return &RouteGroup{
		mux:             g.mux,
		prefix:          prefix,
		middlewares:     append(append([]Middleware{}, g.middlewares...), middlewares...),
		registeredPaths: g.registeredPaths,
	}
}

// Use applies middlewares to all routes registered after this call
// Returns the RouteGroup for method chaining
func (g *RouteGroup) Use(middlewares ...Middleware) *RouteGroup {
	g.middlewares = append(g.middlewares, middlewares...)
	return g
}

// HandleFunc registers a handler function for the given method and pattern
func (g *RouteGroup) HandleFunc(method, pattern string, handler http.HandlerFunc, middlewares ...Middleware) {
	// Apply the prefix to the pattern
	fullPattern := g.prefix
	if g.prefix == "/" && pattern != "/" {
		fullPattern = pattern
	} else if pattern == "/" {
		fullPattern = g.prefix
	} else {
		fullPattern = g.prefix + pattern
	}
	
	// Check if the route is already registered
	routeKey := method + " " + fullPattern
	if g.registeredPaths[routeKey] {
		// Either return an error or log a warning
		// For now, we'll just print a warning
		fmt.Printf("Warning: Route already registered: %s\n", routeKey)
		return
	}
	
	// Apply middleware chain to the handler
	var finalHandler http.Handler = handler
	
	// Apply route-specific middlewares first (innermost)
	for i := len(middlewares) - 1; i >= 0; i-- {
		finalHandler = middlewares[i](finalHandler)
	}
	
	// Apply group middlewares (outermost)
	for i := len(g.middlewares) - 1; i >= 0; i-- {
		finalHandler = g.middlewares[i](finalHandler)
	}
	
	// Register the handler with the ServeMux
	g.mux.HandleFunc(routeKey, finalHandler.ServeHTTP)
	
	// Mark the route as registered
	g.registeredPaths[routeKey] = true
}

// ServeHTTP implements the http.Handler interface
func (g *RouteGroup) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	g.mux.ServeHTTP(w, req)
}