// Code generated by protoc-gen-go-http-server-interface. DO NOT EDIT.
package {{ .PackageName }}

import (
	"net/http"
	"strings"
)

// Middleware represents a middleware function that wraps an http.Handler
type Middleware func(http.Handler) http.Handler

// Routes defines methods for registering routes
type Routes interface {
	// HandleFunc registers a handler function for the given method and pattern
	HandleFunc(method, pattern string, handler http.HandlerFunc, middlewares ...Middleware)
	
	// Group creates a new RouteGroup with the given prefix and optional middlewares
	Group(prefix string, middlewares ...Middleware) *RouteGroup
	
	// Use applies middlewares to all routes registered after this call
	Use(middlewares ...Middleware) *RouteGroup
}

// RouteGroup represents a group of routes with a common prefix and middleware
type RouteGroup struct {
	prefix          string
	middlewares     []Middleware
	routes          []routeDef
	mux             *http.ServeMux
}

// routeDef stores a route definition before it's registered with the mux
type routeDef struct {
	method      string
	pattern     string
	handler     http.Handler
}

// NewRouter creates a new router with an optional mux
// If mux is nil, a new http.ServeMux will be created
func NewRouter(mux *http.ServeMux) *RouteGroup {
	if mux == nil {
		mux = http.NewServeMux()
	}
	
	return &RouteGroup{
		prefix:       "",
		middlewares:  []Middleware{},
		routes:       []routeDef{},
		mux:          mux,
	}
}

// DefaultRouter creates a new router with a new ServeMux
// This function exists for backward compatibility
func DefaultRouter() *RouteGroup {
	return NewRouter(nil)
}

// Group creates a new RouteGroup with the given prefix and optional middlewares
func (g *RouteGroup) Group(prefix string, middlewares ...Middleware) *RouteGroup {
	// Ensure prefix starts with /
	if prefix != "" && !strings.HasPrefix(prefix, "/") {
		prefix = "/" + prefix
	}
	
	// If prefix is just "/", don't add it again
	if g.prefix == "/" && prefix == "/" {
		prefix = "/"
	} else if prefix == "/" {
		prefix = g.prefix
	} else {
		prefix = g.prefix + prefix
	}
	
	// Combine parent and new middlewares, filtering out nils
	combinedMiddlewares := make([]Middleware, 0, len(g.middlewares)+len(middlewares))
	for _, mw := range g.middlewares {
		if mw != nil {
			combinedMiddlewares = append(combinedMiddlewares, mw)
		}
	}
	for _, mw := range middlewares {
		if mw != nil {
			combinedMiddlewares = append(combinedMiddlewares, mw)
		}
	}

	return &RouteGroup{
		prefix:       prefix,
		middlewares:  combinedMiddlewares,
		routes:       []routeDef{}, // Each group gets its own routes slice
		mux:          g.mux,        // Share the same mux
	}
}

// Use applies middlewares to all routes registered after this call
func (g *RouteGroup) Use(middlewares ...Middleware) *RouteGroup {
	// Filter out nil middlewares before appending
	for _, mw := range middlewares {
		if mw != nil {
			g.middlewares = append(g.middlewares, mw)
		}
	}
	return g
}

// HandleFunc registers a handler function for the given method and pattern
func (g *RouteGroup) HandleFunc(method, pattern string, handler http.HandlerFunc, middlewares ...Middleware) {
	// Apply the prefix to the pattern
	fullPattern := g.prefix
	if g.prefix == "/" && pattern != "/" {
		fullPattern = pattern
	} else if pattern == "/" {
		fullPattern = g.prefix
	} else {
		fullPattern = g.prefix + pattern
	}

	// Apply middleware chain to the handler
	var finalHandler http.Handler = handler

	// Filter and collect route-specific middlewares
	validMiddlewares := make([]Middleware, 0, len(middlewares))
	for _, mw := range middlewares {
		if mw != nil {
			validMiddlewares = append(validMiddlewares, mw)
		}
	}

	// Apply route-specific middlewares first (innermost)
	for i := len(validMiddlewares) - 1; i >= 0; i-- {
		finalHandler = validMiddlewares[i](finalHandler)
	}

	// Apply group middlewares (outermost)
	for i := len(g.middlewares) - 1; i >= 0; i-- {
		mw := g.middlewares[i]
		if mw != nil {
			finalHandler = mw(finalHandler)
		}
	}
	
	// Store and register the route definition
	routeDefinition := routeDef{
		method:   method,
		pattern:  fullPattern,
		handler:  finalHandler,
	}
	g.routes = append(g.routes, routeDefinition)

	// Register with mux if available
	if g.mux != nil {
		routeDefinitionKey := routeDefinition.method + " " + routeDefinition.pattern
		g.mux.Handle(routeDefinitionKey, routeDefinition.handler)
	}

}

func (g RouteGroup) GetRoutes() []string {
	routes := make([]string, len(g.routes))
	for i, route := range g.routes {
		routes[i] = route.method + " " + route.pattern
	}
	return routes
}


// ServeHTTP implements the http.Handler interface
func (g *RouteGroup) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if g.mux != nil {
		g.mux.ServeHTTP(w, r)
	} else {
		http.NotFound(w, r)
	}
}